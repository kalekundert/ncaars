#!/usr/bin/env python3

import pyrosetta
import logging
import autoprop
import byoc

from pyrosetta import rosetta
from pyrosetta.rosetta.std import vector_std_string as vector_str
from pyrosetta.rosetta.protocols.rosetta_scripts import XmlObjects
from pyrosetta.io import pose_from_pdb
from scaffold import Scaffold
from byoc import Key, Method, DocoptConfig
from pathlib import Path

@autoprop
class DesignApp(byoc.App):
    __config__ = [DocoptConfig]

    shared_args = """\
    <pdb>
        The starting model to design.  Chain A of this model must be an aaRS 
        scaffold, and chain X must be an NCAA-adenylate ligand.

    <lig>
        The parameter file for the NCAA-adenylate ligand.

    <scaffold>
        Either the name of a built-in scaffold, or the path to a custom 
        scaffold directory.  If specified, default values for various design 
        parameters will be taken from the scaffold."""
    shared_options = """\
    -f --scorefxn <name>
        Which score function to use.  This overrides the score function 
        specified in the scaffold (i.e. the score function that the scaffold 
        was relaxed with), so this option should never be used for production 
        simulations.

    -r --resfile <path>
        The path to the resfile to use.  This overrides the default resfile 
        that may be specified in the scaffold.

    -p --pssm <path>
        The path to a PSSM matrix generated by PSI-BLAST.  This overrides the 
        default PSSM that may be specified in the scaffold.

    -d --debug-run
        Abbreviate any time intensive steps, for the purpose of debugging 
        rosetta and the like.  Note that unlike `--dry-run`, the command will 
        still run every simulation, just for fewer iterations.  Note that it is 
        often possible to further abbreviate protocols by providing a resfile 
        with very few (e.g. 2-5) allowed mutations.

    -D --dry-run
        Skip any time intensive steps, for the purpose of testing how this 
        command fits into the larger pipeline."""

    pdb_path = byoc.param(
            Key(DocoptConfig, '<pdb>'),
    )
    lig_path = byoc.param(
            Key(DocoptConfig, '<lig>'),
    )
    scaffold = byoc.param(
            Key(DocoptConfig, '<scaffold>'),
            cast=Scaffold,
    )
    scorefxn = byoc.param(
            Key(DocoptConfig, '--scorefxn'),
            Method(lambda self: self.scaffold.scorefxn),
    )
    resfile_path = byoc.param(
            Key(DocoptConfig, '--resfile'),
            Method(lambda self: self.scaffold.resfile_path),
    )
    pssm_path = byoc.param(
            Key(DocoptConfig, '--pssm'),
            Method(lambda self: self.scaffold.pssm_path),
    )
    debug_run = byoc.param(
            Key(DocoptConfig, '--debug-run'),
            default=False,
    )
    dry_run = byoc.param(
            Key(DocoptConfig, '--dry-run'),
            default=False,
    )

    def main(self):
        self.load(DocoptConfig)

    def get_pose(self):
        return pose_from_pdb(self.pdb_path)

class Output1:
    default_output_path = 'out.pdb'
    output_options = """\
    -o --output <path>
        The path where the output files should be written."""

    output_path = byoc.param(
            Key(DocoptConfig, '--output'),
            Method(lambda self: self.default_output_path),
            cast=Path,
    )

    def dump_pdb(self, pose, logger):
        self.output_path.parent.mkdir(exist_ok=True, parents=True)
        logger.info(f"Writing pose to: {self.output_path}")
        pose.dump_pdb(str(self.output_path))

class OutputN:
    default_n = 10
    default_output_dir = 'out'
    output_options = """\
    -n <int>
        The number of designs to generate.

    -o --output <path>
        The path where the output files should be written.  The path should 
        include a format specification (e.g. '{}'), which will be replaced by a 
        unique index for each output.  Without this, outputs may overwrite each 
        other."""

    n = byoc.param(
            Key(DocoptConfig, '-n'),
            Method(lambda self: self.default_n),
            cast=int,
    )
    output_path = byoc.param(
            Key(DocoptConfig, '--output'),
            Method(lambda self: f'{self.default_output_dir}/{{:03}}.pdb.gz'),
    )

    def dump_pdb(self, pose, i, logger):
        out_path = self.output_path.format(i)
        Path(out_path).parent.mkdir(exist_ok=True, parents=True)
        logger.info(f"Writing pose to: {out_path}")
        pose.dump_pdb(out_path)

def init_rosetta(*flags, test_cycles=False, dry_run=False):
    flags = list(flags)
    flags += [
            '-packing:ignore_ligand_chi', True,
    ]
    if test_cycles:
        flags.append('-run:test_cycles')
    if dry_run:
        flags.append('-run:dry_run')

    pyrosetta.init(
            ' '.join(map(str, flags)),
            set_logging_handler='logging',
    )

def init_logging(logger):
    # The reason for using the logging module is to get uniform output 
    # formatting by taking advantage of the fact that pyrosetta can redirect 
    # all of rosetta's output to a logger.
    log = logging.getLogger()
    log.setLevel('WARNING')

    logger.setLevel('DEBUG')
    logging.getLogger('rosetta').setLevel('DEBUG')

    formatter = logging.Formatter('{asctime}\t{name}\t{levelname}\t{message}', style='{')
    handler = logging.StreamHandler()

    for handler in log.handlers[:]:
        log.removeHandler(handler)

    handler.setFormatter(formatter)
    log.addHandler(handler)

def xml_objects(xml_path, script_vars):
    """
    Utility to get access to movers defined in an XML script, while also 
    specifying script variables.

    The pyrosetta API for this is a bit awkward, because the script variables 
    have to be specified using an `OptionCollection`, and for reasons I don't 
    understand, simply instantiating an `OptionCollection` doesn't work.  The 
    work-around is verbose, so this utility helps hide the complexity.
    """
    uo_global = rosetta.basic.options.process()
    uo_local = rosetta.utility.options.OptionCollection(uo_global)
    uo_local.load(vector_str(['-script_vars', *script_vars]), False)

    return XmlObjects.create_from_file(str(xml_path), uo_local)

def kv(key, value):
    """Utility for logging key/value pairs in a consistent format."""
    return f"- {key+':':<35} {value}"

